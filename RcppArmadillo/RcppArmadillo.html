<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>RcppArmadillo</title>
    <meta charset="utf-8" />
    <meta name="author" content="Martin Arnold" />
    <meta name="author" content="Alexander Gerber" />
    <meta name="date" content="2020-01-26" />
    <link rel="stylesheet" href="../xaringan_files/xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="../xaringan_files/custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">








class: center, middle

![:image 100%](../img/armadillo.png)

---
### Armadillo &amp;mdash; FAQs

**What is Armadillo?**

Armadillo is a templated high quality linear algebra library for C++ with good balance between speed and ease of use

**Why use it?**

- Matrix multiplication, inversion and decomposition are indispensible in econometrics and statistics

- C++ (and Rcpp) do not provide suitable classes and methods (in fact, there isn't a method for even matrix multiplication in Rcpp). Coding these by hand is tedious and error prone.

    Armadillo provides well tested matrix classes for integer, floating point and complex numbers and fast methods

**Do I need advanced C++ skills?**

- No. Armadillo uses an easy syntax which is close to that of MATLAB.

- The Armadillo library has a very good documentation at [sourceforge](http://arma.sourceforge.net/docs.html).

---
### `RcppArmadillo` &amp;mdash; Prerequisites

- `RcppArmadillo` provides an interface from and to Armadillo which is based on the C++/R interface impemented in Rcpp

- The package requires a development toolchain to use which should be already setup if C++ integration with Rcpp works without issues. Setting up `RcppArmadillo` then boils down to installing the package from CRAN

    ```nohighlights
    install.packages('RcppArmadillo')
    library(RcppArmadillo)
    ```
- It is straighfowrd to verify if it works by setting `"RcppArmadillo"` as a dependency in `Rcpp::cppFunction()` or `Rcpp::evalCpp()`.

    ```nohighlights
    Rcpp::evalCpp("1 + 1", depends = "RcppArmadillo")
    #&gt; [1] 2
    ```
---
### `RcppArmadillo` &amp;mdash; `sourceCpp()`

- Again the preferred method for compiling Armadillo code is to use a `C++` file with a modified header. The following lines replace the default header:

    ```nohighlights
    #include &lt;RcppArmadillo.h&gt;
    // [[Rcpp::depends(RcppArmadillo)]]
    ```
    
    This ensures that the C++ library headers `Rcpp.h` and `Armadillo.h` are included and adds `RcppArmadillo` onto the compiler's search path.

- In what follows we refer explicitly to Armadillo functions by prefixing the namespace. This avoids overlapping of function names. 

    We may specify that the Armadillo package namespace is used by default.

    ```nohighlights
    using namespace arma;
    ```

- `sourceCpp()` then can be used for sourcing the script (on save) just as for `Rcpp` code.

---
### `RcppArmadillo` &amp;mdash; Classes

- The most important Armadillo classes store elements as &lt;tt&gt;double&lt;/tt&gt;:

    ```nohighlights
    arma::mat, arma::vec (arma::colvec, arma::rowvec)
    ```
    Other types are available, e.g. `arma::uvec` and `arma::umat` which store unsigned integers.
    
- There are other classes, e.g. for sparse matrices and higher-dimensional arrays

- All classes have attributes and associated methods which can be accessed using *dot syntax* just as for the STL.

    **Example: Attributes and Methods**

    ```nohighlights
    arma::mat I(10, 10);   //define 10x10 matrix
    int n = I.n_rows();    //get number of rows
    I.eye();               //transform to identity matrix
    ```
    
---
### `RcppArmadillo` 

**Example: inner vector product**

```nohighlights
// using Rcpp
double inner_prod_rcpp(NumericVector x, NumericVector y) {
  int K = x.length();
  double ip = 0;
  for (int k = 0; k &lt; K; k++) {
    ip += x(k) * y(k);
  }
  return(ip);
}
```
Note that matrix multiplication requires two loops which looks even more bulky.
```nohighlights
// using RcppArmadillo
double inner_prod_rcpparma(arma::vec x, arma::vec y) {
  arma::mat out = x.t() * y;
  return(out(0));
}
```

---
### `RcppArmadillo` 

**Example: inner vector product**

It's faster.




```r
x &lt;- rnorm(1e4); y &lt;- rnorm(1e4)
bench::mark(
  t(x) %*% y,       
  inner_prod_rcpp(x, y),
  inner_prod_rcpparma(x, y),
  check = F,
  relative = T
)[, 1:5]
```

```
## # A tibble: 3 x 5
##   expression                  min median `itr/sec` mem_alloc
##   &lt;bch:expr&gt;                &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1 t(x) %*% y                 1.86   2.98      1         32.9
## 2 inner_prod_rcpp(x, y)      2.01   1.98      1.64       1  
## 3 inner_prod_rcpparma(x, y)  1      1         3.25       1
```

---
### `RcppArmadillo` 

**Example: eigenvalues of real symmetric matrix**



```nohighlights
arma::vec Eigenvals_Armadillo(arma::mat A) {
  return arma::eig_sym(A);
}
```


```r
X &lt;- rnorm(1000); X &lt;- X %*% t(X)
bench::mark(
  eigen(X)$values,
  Eigenvals_Armadillo(X),
  check = F
)[, 1:4]
```

```
## # A tibble: 2 x 4
##   expression                  min   median `itr/sec`
##   &lt;bch:expr&gt;             &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt;
## 1 eigen(X)$values           1.39s    1.39s     0.718
## 2 Eigenvals_Armadillo(X) 349.41ms 351.98ms     2.84
```

---
### `RcppArmadillo` &amp;mdash; Programming Strategy

We recommend a similar procedure as for Rcpp: 

- Write the code in R and divide it into functions if possible so that bottlenecks can be easily identified

- Replace slow components with C++ Armadillo functions that have the same call signature.

- New: Try to keep the number of casts between RcppArmadillo, Rcpp and R data types to a minimum. 

---
### `RcppArmadillo` 

**Example: fast regression**

Rcpp input *by reference* / Rcpp return

```nohighlights
#include &lt;RcppArmadillo.h&gt;
using namespace Rcpp;

// [[Rcpp::export]]
List fastReg_TwoCasts(NumericMatrix Xr,  NumericVector yr) {
    int n = X.n_rows, k = X.n_cols;
    
    arma::mat X(Xr.begin(), n, k, false);
    arma::colvec y(yr.begin(), yr.size(), false);
        
    arma::colvec coef = arma::solve(X, y);
    arma::colvec res  = y-X*coef;

    return List::create(Named("coefficients") = coef);
}
```

---
### `RcppArmadillo` 

**Example: fast regression**

Armadillo input *by value* / Rcpp return

```nohighlights
#include &lt;RcppArmadillo.h&gt;
using namespace Rcpp;

// [[Rcpp::export]]
List fastReg_OneCast(arma::mat X, arma::colvec y) {
    int n = X.n_rows, k = X.n_cols;

    arma::colvec coef = arma::solve(X, y);
    arma::colvec res  = y-X*coef;

    return List::create(Named("coefficients") = coef);
}
```
---
### `RcppArmadillo` 

**Example: fast regression**

Armadillo input *by constant reference* / Rcpp return

```nohighlights
#include &lt;RcppArmadillo.h&gt;
using namespace Rcpp;

// [[Rcpp::export]]
List fastReg_ConstRef(const arma::mat&amp; X, const arma::colvec&amp; y) {
    int n = X.n_rows, k = X.n_cols;
        
    arma::colvec coef = arma::solve(X, y);
    arma::colvec res  = y-X*coef;

    return List::create(Named("coefficients") = coef);
}
```

---
### `RcppArmadillo` 

**Example: fast regression**

Armadillo input *by constant reference* / RcppArmadillo return

```nohighlights
#include &lt;RcppArmadillo.h&gt;
using namespace Rcpp;

// [[Rcpp::export]]
arma::mat fastReg_NoCast(const arma::mat&amp; X, const arma::vec&amp; y) {  
 arma::vec b_hat;  
 
 beta_hat = (X.t() * X).i() * X.t() * y;  
 
 return(beta_hat);  
}
```

---
### `RcppArmadillo` 

**Example: fast regression**




```r
k &lt;- 4; N &lt;- 1e4
X &lt;- cbind(1,matrix(rnorm(N), ncol = k))
Y &lt;- X %*% c(1, runif(k)) + rnorm(N/k)

bench::mark(
    lm(Y ~ X - 1), solve(t(X) %*% X) %*% t(X) %*% Y, lm.fit(X, Y),
    fastReg_TwoCasts(X, Y), fastReg_OneCast(X, Y),
    fastReg_ConstRef(X, Y), fastReg_NoCast(X, Y),
    check = F, relative = T, iterations = 500)[, 1:4]
```

```
## # A tibble: 7 x 4
##   expression                         min median `itr/sec`
##   &lt;bch:expr&gt;                       &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;
## 1 lm(Y ~ X - 1)                    15.0   18.7       1   
## 2 solve(t(X) %*% X) %*% t(X) %*% Y  3.38   5.28      3.63
## 3 lm.fit(X, Y)                      4.20   5.30      3.61
## 4 fastReg_TwoCasts(X, Y)            1.98   2.04      9.16
## 5 fastReg_OneCast(X, Y)             2.08   2.16      8.55
## 6 fastReg_ConstRef(X, Y)            2.03   2.04      9.26
## 7 fastReg_NoCast(X, Y)              1      1        18.3
```

---
### `RcppArmadillo` 

**Example: simulating a VAR(1) process**

- A VAR(1) process is given by `$$\mathbf{y}_t = \mathbf{A}\mathbf{y}_{t-1} + \boldsymbol{\varepsilon}_t$$` with `\(K\)` endogenous variables `\(\mathbf{y}_t = (y_{1t}, \dots, y_{kt})\)`, `\(\mathbf{A}\)` a `\(K\times K\)` coefficient matrix and `\(\boldsymbol{\varepsilon}_t\)` a `\(K\)` dimensional error process with `\(E(\boldsymbol{\varepsilon}_t) = \mathbf{0}\)` and `\(E(\boldsymbol{\varepsilon}_t \boldsymbol{\varepsilon}_t') = \boldsymbol{\Sigma}_{\boldsymbol{\varepsilon}}\)`.

- `\(\mathbf{y}_t\)` is a stable process if `$$\det(\mathbf{I}_K - \mathbf{A}z) \neq 0$$` for `\(\lvert z\rvert \leq 1\)`. An equivalent condition is that all eigenvalues of `\(\mathbf{A}\)` have modulus less than 1.

- We consider a DGP for `\(K=2\)` variables where `\(\boldsymbol{\varepsilon}_t\)` is bivariate standard normal and `$$\mathbf{A} = \begin{pmatrix}0.8 &amp; 0.15\\ 0.15 &amp; 0.8\end{pmatrix}$$` 

---
### `RcppArmadillo` 

**Example: simulating a VAR(1) process**

Let's check that the DGP generates stable processes.


```r
A &lt;- matrix(c(0.8, 0.15, 0.15, 0.8), ncol = 2)
all(Eigenvals_Armadillo(A) &lt; 1)
```

```
## [1] TRUE
```

We write the DGP as an R function of the coefficient matrix and the error process.


```r
VARSim_R &lt;- function(A, epsilon) {
   out &lt;- matrix(0, nrow(epsilon), ncol(epsilon))
   for (i in 2:nrow(epsilon)) {
      out[i,] &lt;- A %*% out[i-1,] + epsilon[i,]
   }
   return(out)
}
```

---
### `RcppArmadillo` 

**Example: simulating a VAR(1) process**

An Armadillo version is readily implemented

```nohighlights
#include &lt;RcppArmadillo.h&gt;
// [[Rcpp::depends(RcppArmadillo)]]

// [[Rcpp::export]]
arma::mat VARSim_Rcpp(arma::mat coef, arma::mat epsilon) {
  int m = epsilon.n_rows; int n = epsilon.n_cols;
  arma::mat out(m, n, arma::fill::zeros);
  for (int i=1; i&lt;m; i++) {
    out.row(i) = out.row(i-1) * coef.t() + epsilon.row(i);
  }
  return out;
}
```



---
### `RcppArmadillo` 

**Example: simulating a VAR(1) process**

.smaller[

```r
epsilon &lt;- matrix(rnorm(500), ncol = 2)
df &lt;- data.frame(VARSim_Rcpp(A, epsilon)) %&gt;% 
  mutate(time = row_number()) %&gt;% gather(key = "var", value = "y", -time) 

ggplot(df) + geom_line(aes(x=time, y=y, color = var))
```

&lt;img src="RcppArmadillo_files/figure-html/unnamed-chunk-11-1.png" style="display: block; margin: auto;" /&gt;
]

---
### `RcppArmadillo` 

**Example: simulating a VAR(1) process**


```r
bench::mark(
  VARSim_R(A, epsilon),
  VARSim_Rcpp(A, epsilon),
  relative = T)[, 1:4]
```

```
## # A tibble: 2 x 4
##   expression                min median `itr/sec`
##   &lt;bch:expr&gt;              &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;
## 1 VARSim_R(A, epsilon)     48.9   44.6       1  
## 2 VARSim_Rcpp(A, epsilon)   1      1        42.9
```


---
### `RcppArmadillo` &amp;mdash; Case Study: EM Algorithm

.smaller[

**Gaussian mixture model**

A mixture of two univariate Gaussians can be written as
`\begin{align*}
  f(x)=&amp;\sum_{z}f(x,z) = \sum_{z} f(z) f(x\vert z) \\
      =&amp;\pi \mathcal{N}(x\vert\mu_1, \sigma_1)+(1-\pi) \mathcal{N}(x\vert\mu_2, \sigma_2)
\end{align*}`
where `\(z\)` is a latent (i.e. unobserved) binary random variable stating whether `\(x\)` is generated from `\(\mathcal{N}(x\vert\mu_1, \sigma_1)\)` or `\(\mathcal{N}(x\vert\mu_2, \sigma_2)\)`, `$$f(z) = \pi^{z}\cdot(1-\pi)^{1-z}.$$`

The unknown parameters `\(\pi, \mu_1,\mu_2,\sigma_1,\sigma_2\)` are estimated as maximizers of
`\begin{align*}
\log L(x\vert \pi, \mu_1,\mu_2,\sigma_1,\sigma_2) = \sum_{i=1}^N\log\left\{\pi \mathcal{N}(x_i\vert\mu_1, \sigma_1)+(1-\pi) \mathcal{N}(x_i\vert\mu_2, \sigma_2)\right\}.
\end{align*}`
*Expectation-Maximization* (EM) algorithms are a popular choice.
]

---
### `RcppArmadillo` &amp;mdash; Case Study: EM Algorithm

.smaller[

**Gaussian mixture model**

Using the posterior probabilities
`\begin{align*}
  P(z_i=1\vert x_i) =&amp; \gamma_{1i} = \frac{\pi\mathcal{N}(x_i\vert \mu_1, \sigma_1)}{\pi\mathcal{N}(x_i\vert \mu_1, \sigma_1) + (1-\pi)\mathcal{N}(x_i\vert \mu_2,\sigma_2)},\\
  P(z_i=0\vert x_i) =&amp; \gamma_{2i} = 1 - \gamma_{1i},
\end{align*}`
rearranging the first order conditions gives
`\begin{align*}
  \pi =&amp; \frac{1}{n}\sum_{i=1}^n \gamma_{1i}\\
  \mu_1 =&amp; \frac{1}{n}\sum_{i=1}^n\gamma_{1i}x_i/\pi, \quad \mu_2=(\overline{x} - \pi\mu_1)/(1-\pi),\\
  \sigma_1^2 =&amp; \frac{1}{n}\sum_{i=1}^n\gamma_{1i}(x_i-\mu_1)^2, \quad \sigma_2^2 = \frac{1}{n}\sum_{i=1}^n\gamma_{2i}(x_i-\mu_2)^2.
\end{align*}`
This suggests an iterative procedure where we compute compute `\(\gamma_{1i}\)` and `\(\gamma_{2i}\)` and then update the parameters.
]

---
### `RcppArmadillo` &amp;mdash; Case Study: EM Algorithm

**EM for two-component univariate Gaussian mixture model**

1. Initialize `\(\pi\)`, `\(\mu_1\)`, `\(\mu_2\)`, `\(\sigma_1\)`, `\(\sigma_2\)` and compute the log-likelihood.

2. Evaluate `\(\gamma_{1i}\)` and `\(\gamma_{2i}\)` (*E step*)

3. Re-estimate `\(\pi\)`, `\(\mu_1\)`, `\(\mu_2\)`, `\(\sigma_1\)`, `\(\sigma_2\)` as shown on the previous slide (*M step*)

4. Evaluate the likelihood and check for convergence using the likelihood (check if difference in log-likelihood between iterations is smaller than some prespecified `\(\epsilon&gt;0\)`. Return to 2. if the convergence criterion is not met.

---
### `RcppArmadillo` &amp;mdash; Case Study: EM Algorithm

**Complete the following tasks:**

1. Implement an R function which estimates the paramesters of a two-component univariate Gaussian mixture model. The function should allow the user to specify the maximum number of iteration and a tolerance for checking convergence of the log-likelihood.

2. Identify bottlenecks of your function and rewrite it using `Rcpp`/`RcppArmadillo`. Benchmark against the R implementation.

3. Use the function for estimating a two-component mixture model of XXX. Visualise the the results.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="../xaringan_files/macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized-dark",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<script type="text/javascript">
    var hljs = remark.highlighter.engine;
</script>
<script src="terminal.language.js" type="text/javascript"></script>
<script type="text/javascript">
    var slideshow = remark.create({});
    // extract the embedded styling from ansi spans
    var highlighted = document.querySelectorAll("code.terminal span.hljs-ansi");
    Array.prototype.forEach.call(highlighted, function(next) {
    next.insertAdjacentHTML("beforebegin", next.textContent);
    next.parentNode.removeChild(next);
    });
    
    $("code.nohighlights").find("*").removeClass(
"hljs-title hljs-name hljs-number hljs-type hljs-class hljs-keyword hljs-literal hljs-selector-pseudo hljs-built_in hljs-default hljs-symbol")

/*    $("code.r").find("*").removeClass(
"hljs-title hljs-number hljs-type hljs-class hljs-keyword hljs-literal") */
</script>

<style>
   code.terminal.hljs.remark-code {
    background: #272822; color: #ddd;
}
   .hljs-default .hljs-string {
 color: #FFC300;
}
</style>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
